## 1、接口型：
- 适配器模式的意图在于，使用不同接口的类所提供的服务为客户端提供它所期望的接口
- 门面模式（外观模式）：的意图是为子系统提供一个统一的接口。
- 合成模式：其意图是为了保证客户端调用单对象和组合对象的一致性
- 桥接模式：其意图是将抽象与抽象方法的实现相互分离来实现解耦，以便二者可以相互独立地变化，经典列子：jdbc

## 2、职责型
- 单例模式：为了确保一个类有且仅有一个实例，并为它提供一个全局访问点
- 观察者模式：其意图是在多个对象之间定义一对多的依赖关系，当一个对象的状态发生改变时，会通知依赖于它的对象，并根据新状态做出相应的反应
- 调停者模式：定义一个对象，封装一组对象的交互，从而降低对象间的耦合度，避免对象间的显示引用，并且可以独立的变化
- 代理模式：通过提供一个代理对象或者占位符来控制对该对象的访问
- 责任链模式：通过给予多个对象处理请求的机会，已解除请求发送者与接收者之间的耦合
- 享元模式：通过共享来有效的支持大量细粒度的对象

## 3、构造型模式
- 构建者模式：将类的构建逻辑转移到类的实例化外部，实例：android dialog的构建；
- 工厂方法模式：定义一个用于创建对象的接口，并控制返回那个类；
- 抽象工厂模式：允许创建一族相关或相互依赖的对象
- 原型模式（prototype）：通过复制一个现有的对象来生成新的对象，而不是通过实例化的方式
- 备忘录模式：为对象的状态提供存储和恢复的功能

## 4、操作型模式
- 模板方法模式：在一个方法里实现一个算法，并推迟定义算法中的某些步骤，从而让其他类重新定义它们
- 状态模式：将标识对象状态的逻辑分散到代表状态的不同类中
- 策略模式：将可互换的方法封装在独立的类中，并且让每个方法都实现一个公共的操作
- 命令模式：将请求封装在对象的内部
- 解析器模式：根据事先定义好的一系列组合规则，组成可执行对象。
## 扩展型设计模式
- 装饰器模式：在运行时组合操作的新变化
- 迭代器模式：为顺序访问集合元素提供一种方式
- 访问者模式：在不改变类层次结构的前提下，对改层次结构进行拓展